(define-module pattern.pattern
  (use chase_evade.bresenham)
  (use srfi-1)
  (export-all)
  )


(select-module pattern.pattern)

(define-class <pattern> ()
  ((pattern :init-value '()
            :accessor pattern-of)
   (offset :init-value '(0 . 0)
           :accessor offset-of)))

(define-method build-path-segment! ((pattern <pattern>) sx sy ex ey)
  (set! (pattern-of p)
        (append (pattern-of p)
                (if (null? (pattern-of p))
                    (bresenham sx sy ex ey)
                    (cdr (bresenham sx sy ex ey))))))

(define-method normalize! ((p <pattern>))
  (let ((sx (caar (pattern-of p)))
        (sy (cdar (pattern-of p))))    
    (map! (lambda (x)
            (cons (- (car x) sx)
                  (- (cdr x) sy)))          
          (pattern-of p))))

(define-method set-offset! ((p <pattern>) ofs)
  (set! (offset-of p) ofs))


(define p (make <pattern>))
(build-path-segment! p 4 4 10 10)
(build-path-segment! p 10 10 5 5)
(build-path-segment! p 5 5 4 4)
(normalize! p)
(print (pattern-of p))
(set-offset! p '(2 . 2))
(print (offset-of p))




(provide "pattern/pattern")

